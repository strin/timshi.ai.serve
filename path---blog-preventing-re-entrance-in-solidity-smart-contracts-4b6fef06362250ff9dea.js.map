{"version":3,"sources":["webpack:///path---blog-preventing-re-entrance-in-solidity-smart-contracts-4b6fef06362250ff9dea.js","webpack:///./.cache/json/blog-preventing-re-entrance-in-solidity-smart-contracts.json"],"names":["webpackJsonp","424","module","exports","data","butterPost","slug","url","published","title","body","summary","seo_title","meta_description","author","first_name","last_name","twitter_handle","pathContext","_PARENT"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,YAAcC,KAAA,qDAAAC,IAAA,iFAAAC,UAAA,uBAAAC,MAAA,qCAAAC,KAAA,09GAAolHC,QAAA,mFAAAC,UAAA,qDAAAC,iBAAA,wIAAAC,QAAmbC,WAAA,MAAAC,UAAA,WAAAC,eAAA,kBAA4EC,aAAgBZ,KAAA,qDAAAa,QAAA","file":"path---blog-preventing-re-entrance-in-solidity-smart-contracts-4b6fef06362250ff9dea.js","sourcesContent":["webpackJsonp([212789916069284],{\n\n/***/ 424:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"butterPost\":{\"slug\":\"preventing-re-entrance-in-solidity-smart-contracts\",\"url\":\"http://youfoundron.com/blog/preventing-re-entrance-in-solidity-smart-contracts\",\"published\":\"2017-08-13T23:19:00Z\",\"title\":\"Preventing Re-Entrance in Solidity\",\"body\":\"<p>I recently was tasked with writing a smart contract that would equally distribute&nbsp;sent funds between several recipients, all of whom could publicly add themselves to&nbsp;the contract.</p>\\r\\n<p>Simple enough it would seem; hold a list of recipient addresses and add a sender's address when they call the public <code>becomeRecipient</code>&nbsp;function.</p>\\r\\n<pre class=\\\"language-undefined\\\"><code>contract FundDistributor {\\r\\n  address   public owner;\\r\\n  address[] public recipients;\\r\\n\\r\\n  function FundDistributor () {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  function becomeRecipient () public {\\r\\n    recipients.push(msg.sender);\\r\\n  }\\r\\n\\r\\n  function distributeFunds () payable {\\r\\n    /* ... */\\r\\n  }\\r\\n}</code></pre>\\r\\n<p>It is pretty obvious that in the contract's current form, a recipient could repeatedly&nbsp;re-enter themselves and receive a larger share of the distributed&nbsp;funds.</p>\\r\\n<p>Given&nbsp;the contract's&nbsp;existing state variables, checking if a sender's address is in the list of recipients would require a&nbsp;linear search. Not very fancy coding!</p>\\r\\n<p>Okay fine, let's use a mapping instead. It should store keys as addresses and values&nbsp;as booleans.</p>\\r\\n<pre class=\\\"language-undefined\\\"><code>contract FundDistributor {\\r\\n  address   public owner;\\r\\n  mapping(address =&gt; bool) public recipients;\\r\\n\\r\\n  modifier notRecipient () {\\r\\n    require(!recipients[msg.sender]);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function FundDistributor () {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  function becomeRecipient () notRecipient() public {\\r\\n    recipients[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  function distributeFunds () payable {\\r\\n    /* ... */\\r\\n  }\\r\\n}</code></pre>\\r\\n<p>Booleans will default to false. So anytime someone calls <code>becomeRecipient</code>&nbsp;we can update the mapping with a key/value pair so that when the recipient address is looked up, it returns true.</p>\\r\\n<p>This makes writing a modifier to prevent re-entrance pretty straight forward! Simply lookup the sender's address in the recipients mapping and throw if the value is true.</p>\\r\\n<p>However, mappings in Solidity are not iterable. This poses an issue if we'd like to somehow display&nbsp;our recipients in our UI or even send funds to each recipient.&nbsp;There are library contracts that will provide this functionality for us, but I think the solution in our case is pretty simple.</p>\\r\\n<p>Use both an array&nbsp;and a mapping! The array&nbsp;to hold recipient addresses and the mapping to hold a recipient's index on&nbsp;the list.</p>\\r\\n<pre class=\\\"language-undefined\\\"><code>contract FundDistributor {\\r\\n  address   public owner;\\r\\n  address[] public recipients;\\r\\n  mapping(address =&gt; uint) public recipientIndexes;\\r\\n\\r\\n  modifier notRecipient () {\\r\\n    if (recipients.length &gt; 0) {\\r\\n      uint index = recipientIndexes[msg.sender];\\r\\n      address recipient = recipients[index];\\r\\n      require(msg.sender != recipients[index]);        \\r\\n    }\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function FundDistributor () {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  function becomeRecipient () notRecipient() public {\\r\\n    // push returns the new length of the list\\r\\n    recipientIndexes[msg.sender] = recipients.push(msg.sender) - 1;\\r\\n  }\\r\\n\\r\\n  function distributeFunds () payable {\\r\\n    /* ... */\\r\\n  }\\r\\n}</code></pre>\\r\\n<p>By updating the&nbsp;contract we've secured the ability to look up previous recipients and keep our array of addresses in tact!</p>\",\"summary\":\"How do we prevent individuals from re-entering themselves into a smart contract?\",\"seo_title\":\"Preventing Re-Entrance in Solidity Smart Contracts\",\"meta_description\":\"How might we track participants in a smart contract, and how do we prevent individuals from re-entering themselves into the contract?\",\"author\":{\"first_name\":\"Ron\",\"last_name\":\"Gierlach\",\"twitter_handle\":\"@youfoundron\"}}},\"pathContext\":{\"slug\":\"preventing-re-entrance-in-solidity-smart-contracts\",\"_PARENT\":\"SOURCE\"}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-preventing-re-entrance-in-solidity-smart-contracts-4b6fef06362250ff9dea.js","module.exports = {\"data\":{\"butterPost\":{\"slug\":\"preventing-re-entrance-in-solidity-smart-contracts\",\"url\":\"http://youfoundron.com/blog/preventing-re-entrance-in-solidity-smart-contracts\",\"published\":\"2017-08-13T23:19:00Z\",\"title\":\"Preventing Re-Entrance in Solidity\",\"body\":\"<p>I recently was tasked with writing a smart contract that would equally distribute&nbsp;sent funds between several recipients, all of whom could publicly add themselves to&nbsp;the contract.</p>\\r\\n<p>Simple enough it would seem; hold a list of recipient addresses and add a sender's address when they call the public <code>becomeRecipient</code>&nbsp;function.</p>\\r\\n<pre class=\\\"language-undefined\\\"><code>contract FundDistributor {\\r\\n  address   public owner;\\r\\n  address[] public recipients;\\r\\n\\r\\n  function FundDistributor () {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  function becomeRecipient () public {\\r\\n    recipients.push(msg.sender);\\r\\n  }\\r\\n\\r\\n  function distributeFunds () payable {\\r\\n    /* ... */\\r\\n  }\\r\\n}</code></pre>\\r\\n<p>It is pretty obvious that in the contract's current form, a recipient could repeatedly&nbsp;re-enter themselves and receive a larger share of the distributed&nbsp;funds.</p>\\r\\n<p>Given&nbsp;the contract's&nbsp;existing state variables, checking if a sender's address is in the list of recipients would require a&nbsp;linear search. Not very fancy coding!</p>\\r\\n<p>Okay fine, let's use a mapping instead. It should store keys as addresses and values&nbsp;as booleans.</p>\\r\\n<pre class=\\\"language-undefined\\\"><code>contract FundDistributor {\\r\\n  address   public owner;\\r\\n  mapping(address =&gt; bool) public recipients;\\r\\n\\r\\n  modifier notRecipient () {\\r\\n    require(!recipients[msg.sender]);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function FundDistributor () {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  function becomeRecipient () notRecipient() public {\\r\\n    recipients[msg.sender] = true;\\r\\n  }\\r\\n\\r\\n  function distributeFunds () payable {\\r\\n    /* ... */\\r\\n  }\\r\\n}</code></pre>\\r\\n<p>Booleans will default to false. So anytime someone calls <code>becomeRecipient</code>&nbsp;we can update the mapping with a key/value pair so that when the recipient address is looked up, it returns true.</p>\\r\\n<p>This makes writing a modifier to prevent re-entrance pretty straight forward! Simply lookup the sender's address in the recipients mapping and throw if the value is true.</p>\\r\\n<p>However, mappings in Solidity are not iterable. This poses an issue if we'd like to somehow display&nbsp;our recipients in our UI or even send funds to each recipient.&nbsp;There are library contracts that will provide this functionality for us, but I think the solution in our case is pretty simple.</p>\\r\\n<p>Use both an array&nbsp;and a mapping! The array&nbsp;to hold recipient addresses and the mapping to hold a recipient's index on&nbsp;the list.</p>\\r\\n<pre class=\\\"language-undefined\\\"><code>contract FundDistributor {\\r\\n  address   public owner;\\r\\n  address[] public recipients;\\r\\n  mapping(address =&gt; uint) public recipientIndexes;\\r\\n\\r\\n  modifier notRecipient () {\\r\\n    if (recipients.length &gt; 0) {\\r\\n      uint index = recipientIndexes[msg.sender];\\r\\n      address recipient = recipients[index];\\r\\n      require(msg.sender != recipients[index]);        \\r\\n    }\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function FundDistributor () {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  function becomeRecipient () notRecipient() public {\\r\\n    // push returns the new length of the list\\r\\n    recipientIndexes[msg.sender] = recipients.push(msg.sender) - 1;\\r\\n  }\\r\\n\\r\\n  function distributeFunds () payable {\\r\\n    /* ... */\\r\\n  }\\r\\n}</code></pre>\\r\\n<p>By updating the&nbsp;contract we've secured the ability to look up previous recipients and keep our array of addresses in tact!</p>\",\"summary\":\"How do we prevent individuals from re-entering themselves into a smart contract?\",\"seo_title\":\"Preventing Re-Entrance in Solidity Smart Contracts\",\"meta_description\":\"How might we track participants in a smart contract, and how do we prevent individuals from re-entering themselves into the contract?\",\"author\":{\"first_name\":\"Ron\",\"last_name\":\"Gierlach\",\"twitter_handle\":\"@youfoundron\"}}},\"pathContext\":{\"slug\":\"preventing-re-entrance-in-solidity-smart-contracts\",\"_PARENT\":\"SOURCE\"}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-preventing-re-entrance-in-solidity-smart-contracts.json\n// module id = 424\n// module chunks = 212789916069284"],"sourceRoot":""}