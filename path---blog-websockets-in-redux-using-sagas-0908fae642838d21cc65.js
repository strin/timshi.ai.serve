webpackJsonp([0xd2e47ac7cd4d],{427:function(e,n){e.exports={data:{butterPost:{slug:"websockets-in-redux-using-sagas",url:"http://youfoundron.com/blog/websockets-in-redux-using-sagas",published:"2017-06-20T05:24:00Z",title:"WebSockets in Redux: Using Sagas",body:'<p>In&nbsp;<a title="Write Your Own Middleware" href="http://youfoundron.com/blog/websockets-in-redux-two-approaches" target="_blank" rel="noopener noreferrer">part one</a>&nbsp;we wrote our own Redux middleware to manage&nbsp;WebSockets. In this post I\'ll be covering a&nbsp;second approach using Redux Saga.</p>\r\n<p>For those of you unfamiliar with Redux Saga this could get&nbsp;a little confusing, however,&nbsp;some cursory examination of the <a title="Redux Saga docs" href="https://redux-saga.js.org/" target="_blank" rel="noopener noreferrer">documentation</a> should get you up to speed.</p>\r\n<p>At their basis, Sagas&nbsp;boil down to a pattern for handling&nbsp;side-effects using <a title="Generator Function" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" rel="noopener noreferrer">ES6 Generator functions</a>. They aim to replace where otherwise&nbsp;you may&nbsp;have used a middleware like Redux Thunk in combination with&nbsp;<code>async / await</code>&nbsp;or just some good ol\' fashioned callbacks.</p>\r\n<p>The&nbsp;main strategy in the case of an external event source like a WebSocket is to use the <code>eventChannel</code> factory function -- it&nbsp;will take a subscriber function that establishes the event source (our WebSocket) and then emits the relevant events to our expectant saga. Read more on this <a title="eventChannel" href="https://github.com/redux-saga/redux-saga/blob/master/docs/advanced/Channels.md#using-the-eventchannel-factory-to-connect-to-external-events" target="_blank" rel="noopener noreferrer">here</a>.</p>\r\n<p>Presuming the same action types and action creators from the first post, let\'s write our Channel factory&nbsp;below:</p>\r\n<pre class="language-javascript"><code>import { eventChannel } from \'redux-saga\'\r\nimport { bindActionCreators } from \'redux\'\r\n\r\nconst connectSocket = ({\r\n  socketURL, // the url our socket connects to\r\n  subscribeData, // the handshake data our socket will send once connected (optional)\r\n  eventHandlers // the actions we want our socket to dispatch\r\n}) =&gt; eventChannel(\r\n  emitter =&gt; {\r\n    // instantiate the web socket\r\n    const ws = new window.WebSocket(socketURl)\r\n    // bind eventHandlers to emitter\r\n    const boundEventHandlers = bindActionCreators(eventHandlers, emitter)\r\n    // emit onopen event, and fire off a subscribe message with our handshake data\r\n    ws.onopen = e =&gt; {\r\n      boundEventHandlers.onopen(e)\r\n      ws.send(JSON.stringify({ type: \'subscribe\', ...subscribeData }))\r\n    }\r\n    // assign remaining event handlers\r\n    ws.onclose = boundEventHandlers.onclose\r\n    ws.onerror = boundEventHandlers.onerror\r\n    ws.onmessage = boundEventHandlers.onmessage\r\n    return ws.close\r\n  }\r\n)</code></pre>\r\n<p>You\'ve probably already noticed that the body of our Channel is nearly&nbsp;<em>identical</em> to the body of our middleware from the first post!</p>\r\n<p>If you\'re still with me, let\'s take our Channel to task and&nbsp;use it in a Saga:</p>\r\n<pre class="language-javascript"><code>import { effects, takeEvery } from \'redux-saga\'\r\nconst { call, put, take } = effects\r\n\r\n// saga for our WebSocket\r\nconst socketSaga = function * (action) {\r\n  const socketChannel = yield call(connectSocket, action.payload)\r\n  while (true) {\r\n    const eventAction = yield take(socketChannel)\r\n    yield put(eventAction)\r\n  }\r\n}\r\n\r\n// rootSaga for our store, listens for \'SOCKET_CONNECT\' dispatch\r\nconst rootSaga = function * (action) {\r\n  yield takeEvery(types.SOCKET_CONNECT, socketSaga)\r\n}\r\n</code></pre>\r\n<p>Look at that while loop, what the heck is going on here?! It\'s actually not so crazy, I promise.</p>\r\n<p>The <code>yield</code> flag causes execution inside the generator function to pause (think of it as a generator function\'s version of a&nbsp;<code>return</code>&nbsp;statement)&nbsp;before resuming iteration. This pattern allows us to respond to a constant stream of WebSocket-initiated action dispatches as they fire.</p>\r\n<p>With our sagas&nbsp;at the ready, we just need to change our previously written <code>socketConnect</code> action to return a payload with all our relevant WebSocket instantiation arguments.</p>\r\n<pre class="language-javascript"><code>const actionCreators = {\r\n  /* ...other action creators... */\r\n  socketConnect: opts =&gt; ({\r\n    type: types.SOCKET_CONNECT,\r\n    payload: {\r\n      socketURL: opts.socketURL,\r\n      subscribeData: opts.subscribeData,\r\n      eventHandlers: opts.eventHandlers\r\n    }\r\n  })\r\n}</code></pre>\r\n<p>&nbsp;Note that these arguments could have been declared&nbsp;in the Channel factory itself or really at any stage prior to&nbsp;socket instantiation.</p>\r\n<p>The only step left will be for you to add Redux Saga middleware to your store, instructions to which may be found <a href="https://redux-saga.js.org/docs/introduction/BeginnerTutorial.html#hello-sagas">here</a>.</p>\r\n<p>I hope you\'ve found&nbsp;at least one of these approaches helpful and can start using WebSockets with your Redux application today!</p>',summary:"Writing an event channel listener with Redux Saga.",seo_title:"WebSockets in Redux: Using Sagas",meta_description:"Part Two.  Write your own event channel listener with Redux Sagas.",author:{first_name:"Ron",last_name:"Gierlach",twitter_handle:"@youfoundron"}}},pathContext:{slug:"websockets-in-redux-using-sagas",_PARENT:"SOURCE"}}}});
//# sourceMappingURL=path---blog-websockets-in-redux-using-sagas-0908fae642838d21cc65.js.map